[![Build and Test](https://github.com/open205/libtk205/actions/workflows/build-and-test.yml/badge.svg)](https://github.com/open205/libtk205/actions/workflows/build-and-test.yml)

libtk205
===========

A C++ library autogenerated from the current version of the ASHRAE Standard 205P data exchange specification. The C++ template code is available in the ASHRAE 205 [toolkit](https://github.com/open205/toolkit-205.git), which also provides cross-format translation of ASHRAE205 schema and examples.

**Disclaimer:** While this library is developed in conjunction with the ASHRAE Standard 205 project committee, it is not an official ASHRAE product or a part of the standard.

About ASHRAE 205
----------------

ASHRAE Standard 205 is "Standard Representation of Performance Simulation Data for HVAC&R and Other Facility Equipment". While the standard is not yet published, public reviews are available at [ASHRAE's online review portal](https://osr.ashrae.org/default.aspx).

The stated purpose of ASHRAE Standard 205 is:

> To facilitate sharing of equipment characteristics for performance simulation by defining standard representations such as data models, data formats, and automation interfaces.

The Standard is intended to support the following use cases:

- **Data Publication** Data publishers (typically equipment manufacturers) use representation specifications to guide implementation of data writing and validity testing software that produces correctly-formed representation files.

- **Application Development** Application developers use representation specifications to guide implementation of software that correctly reads representation data. Such implementations may include validity tests and developers may use representation specification example data for testing purposes.

- **Data Application** Application users use representation specifications to understand and check representation data. Data exchange will generally be automated but the availability of representation specifications facilitates additional data checking when needed.

Generally, a data publisher (e.g., manufacturer) provides an ASHRAE Standard 205 representation of a specific piece of equipment that the application user can load into compliant performance simulation software.

Building libtk205
--------------------

To build the library, use

`cmake -B build` 

to generate build files for an "out-of-source" build directory, then

`cmake --build build --config [Debug/Release]`

to build libtk205.

Testing the library is possible using

`cd build && ctest`

Example Usage
-------------

*libtk205* uses a factory pattern to create and populate instances of a representation. The client is responsible for the allocation and lifetime management of pointers to representations. For example, using an ASHRAE205 representation file chiller.cbor, one might create an RS0001 object as follows:
```
// Header.h
#include "rs0001.h"
std::shared_ptr<tk205::rs0001_ns::RS0001> representation;
```
```
// Impl.cpp
#include "rs0001_factory.h"
using namespace tk205;
representation = std::dynamic_pointer_cast<rs0001_ns::RS0001>(RSInstanceFactory::create("RS0001", "chiller.cbor"));
```
or, to utilize the representation base class,
```
// Header.h
#include "rs_instance_base.h"
std::shared_ptr<tk205::RSInstanceBase> representation;
```
```
#include "rs0001_factory.h"
using namespace tk205;
representation = RSInstanceFactory::create("RS0001", "chiller.cbor");
```

Once the instance is created, any of its public members are available through the pointer interface; see unit test files for implementation examples. Critically, the `calculate_performance` overloaded function returns the equipment performance at a particular set of grid variables:
```
representation->performance.performance_map_cooling.calculate_performance(0.0755, 280.0, 0.0957, 295.0, 0.5);
```
See the ASHRAE205 standard for details about equipment parameterization.

The client may optionally register a callback function that handles libtk205 errors (strings) in the preferred way:

```
void Display_message(tk205::MsgSeverity severity, const std::string &message, void *ctx)
{
    if (severity == tk205::MsgSeverity::ERR_205)
    {
      std::cout << "ERROR: " << message << std::endl;
    }
}

tk205::set_error_handler(Display_message, nullptr);
```

